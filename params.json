{"name":"JS Object Inheritance Implementation","tagline":"Javascript OOP \"done right\"","body":"Introduction\r\n============\r\n\r\nIf there is one thing that people seem to struggle with a lot in Javascript, it's object inheritance. Since Javascript\r\nisn't an object oriented language but prototype based, it's not very easy to write something in an object oriented\r\nfashion. This library is lightweight (a little under 4kb minified) with a sole purpose of allowing you, the developer,\r\nto easily develop applications in an object oriented matter.\r\n\r\n## Features ##\r\n* Object- and function based class bodies\r\n* Extending not only JOII- but also native-objects\r\n* Implementing interfaces\r\n* Implementing traits\r\n* Adding mixins on-the-fly\r\n* Using constructors and destructors\r\n* Overrides & parent inheritance\r\n* Using aliases to beat the scoping troubles\r\n* Supports even Internet Explorer 6\r\n\r\n## Download ##\r\nJOII can be downloaded for free on my <a href=\"https://github.com/haroldiedema/joii\">github page</a>.\r\n\r\n\r\n## Usage ##\r\nJOII comes with a `Class` function which you use to declare classes. This function accepts 2 arguments: an `options`\r\nobject and a `body` function or object. The `options` object is optional and should only be used if you really need it.\r\n\r\n```javascript\r\nvar MyClass = Class(function() {\r\n    // Class without options.\r\n});\r\n\r\nvar MyOtherClass = Class({ extends: MyClass }, function() {\r\n    // Class with options.\r\n});\r\n```\r\n\r\n\r\n## Object vs Function ##\r\nJavascript has objects and functions. The difference between an object and a function is mainly that an object, declared as an actual object, is stateless where a function is not. When using JOII for object oriented programming, it's very important that you're aware of these differences.\r\n\r\n```javascript\r\nvar obj = {\r\n    hello: \"I am an object\",\r\n    world: \"Easy no?\"\r\n}\r\n\r\nvar func = function() {\r\n    this.hello = \"I am a function\";\r\n    this.world = \"Easy no?\"\r\n}\r\n```\r\n\r\nThe reason for this being important is that some elements may only be implemented as objects where others can only be\r\nimplemented as functions. For example, a trait is stateless because it must only contain methods which are copied to\r\nthe designated class. Therefore, a trait can only be declared as an object instead of a function.\r\n\r\n# Usage #\r\n\r\n## Extending classes ##\r\nExtending classes is very easy. Simply pass the object, function or class you wish to extend on in the options of your\r\nown class declaration, like so:\r\n\r\n```javascript\r\nvar MyClass = Class({ extends: AnotherClass }, function() {\r\n    // This class now inherits the properties and methods of 'AnotherClass'\r\n});\r\n```\r\n\r\nYou can also extend classes upon classes upon classes...\r\n```javascript\r\nvar a = Class(function() {\r\n    this.a = 1;\r\n});\r\nvar b = Class({ extends: a }, function() {\r\n    this.b = 2;\r\n});\r\nvar c = Class({ extends: b }, function() {\r\n    this.c = 3;\r\n});\r\nvar foo = Class({ extends: c }, function() {\r\n    this.__construct = function()\r\n    {\r\n        // print: a = 1, b = 2, c = 3\r\n        for (var i in this) {\r\n            console.log(i + ' = ' + this[i]);\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n## Implementing Interfaces ##\r\nObject interfaces allow you to create code which specifies which methods a class must implement, without having to define how these methods are handled. Interfaces are defined using the `Interface` function, the same way as a class is defined.\r\n\r\nAn interface may only contain public properties which define their type. An interface may not contain any functional code. This is the nature of an interface.\r\n\r\n<br>\r\n    <b>Note:</b><br>\r\n    Interfaces may extend on other interfaces, the same way as classes extend on other classes, but a class may not extend on an interface and vice-versa.\r\n\r\n\r\n### Implementation example ###\r\n\r\nAn interface is defined as such:\r\n```javascript\r\nvar iPerson = Interface({\r\n    getName: 'function',\r\n    getEmail: 'function'\r\n});\r\n```\r\n\r\nTop implement an interface, the `implements` option is used.\r\n\r\n```javascript\r\nvar Person = Class({ implements: [iPerson]}, function() {\r\n    this.getName = function() {\r\n        return \"John Smith\";\r\n    }\r\n});\r\n\r\nvar p = new Person();\r\n// Will throw an exception: \"Missing function implementation: getEmail\".\r\n```\r\n\r\nTo verify if a class implements a certain interface, the `implements` method is used. This method is available by default \r\nto any class defined as a JOII-class.\r\n\r\n```javascript\r\nif (p.implements(iPerson)) {\r\n    console.log(p.getName());\r\n}\r\n```\r\n\r\n## Traits & Mix-ins ##\r\nJOII works purposely as a single inheritance system. To solve the horizontal code reuse problem, we give you Traits.\r\n\r\nA Trait is intended to reduce some limitations of single inheritance by enabling a developer to reuse sets of methods \r\nfreely in several independent classes living in different class hierarchies. The semantics of the combination of Traits \r\nand classes is defined in a way which reduces complexity, and avoids the typical problems associated with multiple \r\ninheritance and Mixins.\r\n\r\nThe difference between a trait and a mix-in is that a trait can solely be declared as an object, where a mixin may be a\r\nfunction which hasn't even been instantiated yet.\r\n\r\n### A simple trait example ###\r\n```javascript\r\nvar tMath = {\r\n    add: function(a, b) { return a + b; },\r\n    sub: function(a, b) { return a - b; }\r\n}\r\n```\r\n\r\nTo implement this trait into your class, use the `uses` option. The same as `implements`, `uses` also only accepts an \r\narray of values, like so:\r\n\r\n```javascript\r\nvar MyClass = Class({ uses: [tMath] }, function() {\r\n    \r\n    this.__construct = function() {\r\n        return this.add(2, 4);  // returns: 6\r\n    }\r\n    \r\n});\r\n```\r\n\r\n## Mix-in ##\r\nA mix-in is an on-the-fly injection mechanism to quickly apply logical code to an existing (pre-initialized) class. A usecase for this is debugging an existing object with a \"debugger\" mix-in, which contains a set of debugging tools.\r\n\r\n```javascript\r\nvar MyMixIn = Class(function() {\r\n    // Prints the property 'foo' from whichever class we're mixed into. \r\n    this.mix = function() {\r\n        console.log(this.foo);\r\n    }\r\n});\r\n\r\nvar MyClass = Class(function() {\r\n    this.foo = \"bar\";\r\n});\r\n\r\nvar m = new MyClass();\r\nm.mixin(MyMixIn);\r\nm.mix(); // prints: bar\r\n```\r\n\r\n<div class=\"note\">\r\n    <b>Note:</b><br>\r\n    There is no restriction on the object-type of a mix-in, as long as it can be iterated over to \"copy\" elements from\r\n    the mix-in to the designated class.\r\n</div>\r\n\r\n## Aliases ##\r\nSince you might not always have access to the scope where your classes are declared in, it's possible to give your \r\nclasses an alias which can be used from anywhere. Defining an alias is done using the `name` option. You can then use \r\nthis name in `extends` or `implements` or `uses` by simply passing a string value instead of the direct object.\r\n\r\n```javascript\r\nvar BaseClass = Class({ name: 'example.class' }, function() {\r\n    // A class with an alias.\r\n});\r\n\r\n// Normal inheritance, extending on the direct object.\r\nvar MyClass = Class({ extends: BaseClass }, function() { });\r\n\r\n// Aliased inheritance, extending on the alias.\r\nvar MyClass = Class({ extends: 'example.class' }, function() { });\r\n```\r\n\r\n# Basic usage example #\r\n\r\nIn this example, we'll be creating a set of classes that allow us to create some elements on our website. We'll do this\r\nby creating a Renderer class which renders the HTML, a logger trait and an interface.\r\n\r\n```javascript\r\nvar Example = {};\r\n\r\n// Renderer interface\r\nExample.RendererInterface = Interface({\r\n    /**\r\n     * Create an element and append it to the body of the document.\r\n     *\r\n     * @param string type       div, span, section, etc.\r\n     * @param string class      css-class\r\n     * @param string data       element contents\r\n     *\r\n     * @return DOMElement\r\n     */\r\n     addElement: 'function'\r\n});\r\n\r\n// Renderer class\r\nExample.Renderer = Class({ implements: [Example.RendererInterface] }, function() {\r\n\r\n    this.render_target = null;\r\n    /**\r\n     * @see Example.RendererInterface.createElement\r\n     */\r\n    this.addElement = function(type, class_name, data)\r\n    {\r\n        var el = document.createElement(type);\r\n        el.setAttribute('class', class_name);\r\n        el.innerHTML = data;\r\n        this.render_target.appendChild(el);\r\n    }\r\n});\r\n\r\n// Logger\r\nExample.LoggerTrait = {\r\n    log   : function(msg) { console.log(msg); },\r\n    warn  : function(msg) { console.warn(msg); },\r\n    error : function(msg) { console.error(msg); },\r\n}\r\n\r\n// Presentation Class\r\nExample.Presentation = Class({ extends: Example.Renderer, uses: [Example.LoggerTrait] }, function() {\r\n\r\n    this.__construct = function(target)\r\n    {\r\n        this.render_target = target;\r\n    }\r\n\r\n    this.title = function(title) {\r\n        this.log('Created h1 element: ' + title);\r\n        this.addElement('h1', 'title', title);\r\n    }\r\n\r\n    this.hr = function() {\r\n        this.log('Created hr element');\r\n        this.addElement('hr', null, null);\r\n    }\r\n\r\n    this.paragraph = function(data) {\r\n        this.log('Created paragraph.');\r\n        this.addElement('p', 'paragraph', data);\r\n    }\r\n\r\n});\r\n```\r\n\r\nNow that we have a simple renderer, let's put it to the test. We'll instantiate the `Example.Presentation` class and\r\napply a mix-in to it that will put some things on the screen.\r\n\r\n```javascript\r\nvar MakeAwesumStuff = Class(function() {\r\n\r\n    this.doThings = function()\r\n    {\r\n        this.title('Hello World!')\r\n        this.hr();\r\n        this.paragraph('Lorum ipsum dollarrr spectacularr ahmet.');\r\n    }\r\n\r\n});\r\n\r\n// Instantiate Presentation on document.body as render-target.\r\nvar presentation = new Example.Presentation(document.body);\r\n\r\n// Inject the mix-in\r\npresentation.mixin(MakeAwesumStuff);\r\n\r\n// Execute the mix-in function\r\npresentation.doThings();\r\n```\r\n\r\nA working example of this can be seen here: <a href=\"/projects/joii/joii-basic-usage-example\">/projects/joii/joii-basic-usage-example</a>.","google":"UA-47483356-1","note":"Don't delete this file! It's used internally to help with page regeneration."}